# Go 中的数字常量简介 -- William Kennedy

## 简介
Go 更独特的功能之一是该语言如何实现常量。语言规范中的[常量](http://golang.org/ref/spec#Constants) 规则是 Go 独有的。它们提供了 Go 在编译器级别所需的灵活性，使我们编写的代码具有可读性和直观性，同时仍然保持类型安全的语言。

这篇文章将尝试为什么是数字常量、它们如何以最简单的形式表现以及如何最好地谈论它们奠定基础。有很多细微的差别、术语和概念可能会让我们感到困惑。

## 无类型和有类型的数字常量
在 Go 中，可以使用或不使用类型来声明常量。当我们在代码中声明文字值时，我们实际上是在声明无类型和无名的常量。

以下示例显示了命名和未命名的类型化和非类型化数字常量：
```go
const untypedInteger       = 12345
const untypedFloatingPoint = 3.141592

const typedInteger int           = 12345
const typedFloatingPoint float64 = 3.141592
```
声明左侧的常量是命名常量，右侧的文字值是未命名的常量。

## 数字常量的种类
您的第一直觉可能是认为类型化常量与变量使用相同的类型系统，但事实并非如此。常量有自己的实现来表示我们与它们相关联的值。每个 Go[编译器](http://golang.org/cmd/) 都可以根据自己的意愿灵活地在一组强制性要求中实现[常量](http://golang.org/ref/spec#Constants) 。

声明类型化常量时，声明的类型用于关联类型的精度限制。它不会改变值在内部表示的方式。由于常量的内部表示在不同的编译器之间可能不同，因此最好将常量视为具有**kind**而不是类型。

数字常量可以是以下四种类型之一：整数、浮点数、复数和符文：
```
12345    // kind: integer
3.141592 // kind: floating-point
1E6      // kind: floating-point
```
在上面的例子中，我们声明了三个数字常量，一个是整数类型，两个是浮点类型。文字值的形式将决定常量的类型。当文字值的形式包含小数或指数时，常量属于浮点类型。当形式不包含小数或指数时，常量是整数类型。

## 常量在数学上是精确的
不管实现如何，常量总是被认为在数学上是精确的。这使得 Go 中的常量独一无二。在 C 和 C++ 等其他语言中，情况并非如此。

当有足够的内存来存储它们的整个值时，整数总是可以精确表示的。由于规范要求整数常量至少具有 256 位精度，我们可以肯定地说整数常量在数学上是精确的。

要获得数学上精确的浮点数，编译器可以采用不同的策略和选项。该规范没有说明编译器必须如何做到这一点，它只是指定了一组需要满足的强制性要求。

以下是当今不同的 Go 编译器用来实现数学上精确的浮点数的两种策略：

- 一种策略是将所有浮点数表示为分数，并对这些分数使用有理算术。这就是 go/types 今天所做的，这些浮点数永远不会有任何精度损失。
- 另一种策略是使用精度如此之高的浮点数，以至于它们对于所有实际目的似乎都是精确的。当我们使用几百位的浮点数时，精确和近似之间的区别几乎不存在。这就是今天 gc/gccgo 编译器所做的。

然而，作为开发人员，最好不要考虑编译器正在使用什么内部表示，这是无关紧要的。请记住，所有常量，无论是否声明有类型，都使用相同的表示来存储它们的值，这与变量不同，并且在数学上是精确的。

## 数学上精确的示例
由于常量仅在编译期间存在，因此很难提供一个示例来说明常量在数学上是精确的。一种方法是展示编译器如何让我们声明整数类型的常量，其值远大于最大整数类型所能支持的值。

这是一个可以编译的程序，因为整数类型的常量在数学上是精确的：
```go
package main

import "fmt"

// 比 int64 大得多的值。
const myConst = 9223372036854775808543522345

func main() {
	fmt.Println("将编译")
}
```
如果我们将常量更改为int64类型，这意味着常量现在绑定到 64 位整数的精度限制，程序将不再编译：
```go
package main

import "fmt"

// constant 9223372036854775808543522345 overflows int64
const myConst int64 = 9223372036854775808543522345

func main() {
	fmt.Println("Will NOT Compile")
}

// 编译器错误：
// ./exact-constant.go:8:7: constant 9223372036854775808543522345 overflows int64
```

在这里我们可以看到整数类型的常量可以表示非常大的数字，以及为什么我们说它们在数学上是精确的。

## 数字常量
当我们声明一个无类型的数字常量时，常量值没有必须满足的类型约束：
```go
const untypedInteger       = 12345    // kind: integer
const untypedFloatingPoint = 3.141592 // kind: floating-point
```
在每种情况下，声明左侧的无类型常量与右侧的常量具有相同的类型和值。

当我们声明一个类型化常量时，声明右侧的常量必须使用与左侧声明的类型兼容的形式：
```go
const typedInteger int           = 12345    // kind: integer
const typedFloatingPoint float64 = 3.141592 // kind: floating-point
```

声明右侧的值也必须适合声明类型的范围。例如，这个数字常量声明是无效的：
```go
const myUint8 uint8 = 1000
```
uint8只能表示 0 到 255 之间的数字。这就是我之前说的声明类型用于关联类型的精度限制时的意思。

## 隐式整数类型转换
在 Go 中，变量之间没有隐式类型[转换](http://golang.org/ref/spec#Conversions) 。但是，变量和常量之间的隐式类型转换可以由编译器定期发生。

让我们从隐式整数转换开始：
```go
var myInt int = 123
```

在这个例子中，我们将类型为 integer 的常量123隐式转换为int类型的值。由于常量的形式不使用小数点或指数，因此常量采用类型整数。只要不需要截断，整数类型的常量可以隐式转换为任意长度的有符号和无符号整数变量。

如果常量使用与整数类型兼容的形式，则浮点类型的常量也可以隐式转换为整数变量：
```go
var myInt int = 123.0
```

我们还可以在不为变量声明显式类型的情况下执行隐式类型转换赋值：
```go
var myInt = 123
```

在这种情况下，默认类型的int64用于初始化被赋值为类型为整数的常量123的变量。

## 隐式浮点类型转换
接下来让我们看一下隐式浮点转换：
```go
var myFloat float64 = 0.333
```

这一次，编译器在浮点类型的常量0.333到float64类型的变量之间执行隐式转换。由于常量的形式是使用小数点，因此常量采用浮点类型。用浮点类型的常量初始化的变量的默认类型是float64。

编译器还可以在类型为 integer 的常量到类型为float64 的变量之间执行隐式转换：
```go
var myFloat float64 = 1
```

在此示例中，类型为 integer 的常量1被隐式转换为类型为float64的变量。

## 类型变化

在其他常量和变量之间执行常量运算是我们在程序中经常做的事情。它遵循规范中[二元运算符](http://golang.org/ref/spec#Operators) 的规则。该规则规定操作数类型必须相同，除非操作涉及移位或无类型常量。

让我们看一个两个常量相乘的例子：
```go
var answer = 3 * 0.333
```

在这个例子中，我们在类型整数的常量3和类型浮点的常量0.333之间执行乘法。

关于常量表达式的规范中有一条规则是针对此操作的：

*“除了移位操作，如果二元操作的操作数是不同类型的无类型常量，……，结果使用此列表后面出现的类型：整数、符文、浮点数、复数。”*

根据这个规则，这两个常量相乘的结果将是一个浮点类型的常量。基于规则，种类浮点数在种类整数之前被提升。

# 数值常数算术
让我们继续我们的乘法示例：

```go
var answer = 3 * 0.333
```
乘法的结果将是一个新的浮点常量。然后通过从 kind 浮点到float64的隐式类型转换将该常量分配给变量answer。当我们对数值常量进行除法时，常量的种类决定了除法的执行方式。
```go
const third = 1 / 3.0
```

当两个常量之一是浮点类型时，除法的结果也将是浮点类型的常量。在我们的示例中，我们使用小数点来表示分母中的常数。这遵循我们之前谈到的善举规则。

让我们举同样的例子，但在分母中使用种类整数：
```go
const zero = 1 / 3
```

这次我们在两个整数类型的常量之间进行除法。除法的结果将是一个新的整数类型的常量。由于将 3 除以值 1 表示一个小于 1 的数字，因此除法的结果是类整数的常量0。

让我们使用数字常量算法创建一个类型化常量：
```go
type Numbers int8
const One Numbers = 1
const Two         = 2 * One
```

在这里，我们声明了一个名为Numbers的新类型，其基类型为int8。然后我们声明类型为Numbers 的常量One并分配类型为 integer 的常量1。接下来，我们声明常量两个被提升到键入数字通过不断的繁殖2种整数和恒定的一种类型的数字。常量二的声明显示了一个常量不仅提升为用户定义类型，而且提升为与基类型关联的用户定义类型的示例。

## 实际例子
让我们看看标准库中的一个实际示例。time 包声明了这种类型和一组常量：
```go
type Duration int64

const (
    Nanosecond Duration = 1
    Microsecond         = 1000 * Nanosecond
    Millisecond         = 1000 * Microsecond
    Second              = 1000 * Millisecond
)
```
上面声明的所有常量都是Duration类型的常量，其基类型为int64。在这里，我们使用类型化和非类型化常量之间的常量算术来声明类型化常量。

由于编译器会对常量进行隐式转换，我们可以像这样在 Go 中编写代码：
```go
package main

import (
	"fmt"
	"time"
)

const fiveSecond = 5 * time.Second

func main() {
	now := time.Now()
	lessFiveNanoSeconds := now.Add(-5)
	lessFiveSeconds := now.Add(-fiveSecond)

	fmt.Printf("Now     : %v\n", now)
	fmt.Printf("Nano    : %v\n", lessFiveNanoSeconds)
	fmt.Printf("Seconds : %v\n", lessFiveSeconds)

	/**
	OUTPUT:
	Now     : 2021-10-28 10:34:51.210002556 +0800 CST m=+0.000037267
	Nano    : 2021-10-28 10:34:51.210002551 +0800 CST m=+0.000037262
	Seconds : 2021-10-28 10:34:46.210002556 +0800 CST m=-4.99996273
	*/
}

```

常量的威力通过对Add的方法调用得以展现。让我们看一下接收器类型Time的Add方法的定义：

```go
func (t Time) Add(d Duration) Time
```

添加方法接受类型的单个参数持续时间。让我们仔细看看从我们的程序中调用Add的方法：

```go
var lessFiveNanoseconds = now.Add(-5)
var lessFiveMinutes = now.Add(-fiveSeconds)
```
编译器将常量-5隐式转换为Duration类型的变量， 以允许方法调用发生。 由于常量算术规则，常量FiveSeconds已经是Duration类型 ：

```go
const fiveSeconds = 5 * time.Second
```

常数之间的乘法5和time.Second导致恒定fiveSeconds成为类型的恒定持续时间。这是因为常量time.Second属于Duration类型，并且在确定结果类型时会提升此类型。为了支持该函数调用，常数仍然需要从类型的常数被隐式转换持续时间，以类型的变量持续时间。

如果常量没有按照它们的方式运行，这些类型的赋值和函数调用将始终需要显式转换。看看当我们尝试使用int类型的值时会发生什么 进行相同的方法调用：

```go
var difference int = -5
var lessFiveNano = now.Add(difference)
```
```
编译器错误：
cannot use difference (type int) as type time.Duration in argument to now.Add
```
一旦我们使用类型化整数值作为Add方法调用的参数，我们就会收到编译器错误。**编译器将不允许类型变量之间的隐式类型转换**。为了编译该代码，我们需要执行显式类型转换：
```go
Add(time.Duration(difference))
```
**常量是我们无需使用显式类型转换即可编写代码的唯一机制。**

## 结论
我们认为常量的行为是理所当然的，这是对语言设计者和为这个特性努力工作的人的证明。使常量以这种方式工作已经进行了大量的工作和关心，并且好处是显而易见的。

因此，下次您使用常量时，请记住您正在使用独特的东西。埋藏在编译器中的一颗隐藏的宝石，作为 Go 的独特功能没有得到足够的信任或认可。常量有助于使 Go 中的编码变得有趣，并且我们编写的代码可读且直观。同时保持我们编写的代码类型安全。