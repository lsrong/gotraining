## 堆栈和指针的语言机制

### 介绍

指针很难理解。如果使用不当，指针会产生令人讨厌的错误甚至性能问题。在编写并发或多线程软件时尤其如此。难怪如此多的语言试图对程序员隐藏指针。但是，如果您使用 Go 编写软件，则无法避免它们。如果没有对指针的深刻理解，您将很难编写干净、简单和高效的代码。

### 帧边界

函数在帧边界的范围内执行，为每个函数提供单独的存储空间。每个帧都允许一个函数在它们自己的上下文中运行，并提供流控制。函数可以通过帧指针直接访问其帧内的内存，但访问其帧外的内存需要间接访问。对于要访问其框架之外的内存的函数，该内存必须与该函数共享。需要首先理解和学习这些框架边界建立的机制和限制。

调用函数时，两个帧之间会发生转换。代码从调用函数的框架过渡到被调用函数的框架。如果进行函数调用需要数据，则必须将该数据从一帧传输到另一帧。在 Go 中，两帧之间的数据传递是“按值”完成的。

“按值”传递数据的好处是可读性。您在函数调用中看到的值是在另一侧复制和接收的值。这就是我将“按值传递”与所见即所得联系起来的原因，因为所见即所得。所有这些都允许您编写不会隐藏两个函数之间转换成本的代码。这有助于保持一个良好的心理模型，即在转换发生时每个函数调用将如何影响程序。

看看这个执行函数调用的小程序，它“按值”传递整数数据：

**清单 1**

```
01 package main
02
03 func main() {
04
05    // Declare variable of type int with a value of 10.
06    count := 10
07
08    // Display the "value of" and "address of" count.
09    println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")
10
11    // Pass the "value of" the count.
12    increment(count)
13
14    println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")
15 }
16
17 //go:noinline
18 func increment(inc int) {
19
20    // Increment the "value of" inc.
21    inc++
22    println("inc:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
23 }
```

当你的 Go 程序启动时，运行时会创建主 goroutine 来开始执行所有初始化代码，包括`main`函数内部的代码。goroutine 是一条执行路径，它被放置在最终在某个内核上执行的操作系统线程上。从 1.8 版本开始，每个 goroutine 都会被赋予一个初始的 2,048 字节的连续内存块，该块形成其堆栈空间。多年来，这个初始堆栈大小已经发生了变化，并且将来可能会再次发生变化。

堆栈很重要，因为它为分配给每个单独函数的帧边界提供了物理内存空间。当主 goroutine 执行`main`清单 1 中的函数时，goroutine 的堆栈（在非常高的级别）将如下所示：

**图1**

![img](https://www.ardanlabs.com/images/goinggo/80_figure1.png)

您可以在图 1 中看到，堆栈的一部分已被“框定”出来用于该`main`函数。这部分称为“堆栈帧”，正是这个帧表示`main`函数在堆栈上的边界。框架是作为调用函数时执行的代码的一部分建立的。您还可以看到该内存`count`变量已经被放置在地址`0x10429fa4`框里面的`main`。

图 1 阐明了另一个有趣的点。活动帧下方的所有堆栈内存都是无效的，但活动帧及上方的内存是有效的。我需要清楚堆栈的有效部分和无效部分之间的边界。

### 地址

变量用于为特定内存位置分配名称以提高代码可读性并帮助您推理正在处理的数据。如果你有一个变量，那么你在内存中就有一个值，如果你在内存中有一个值，那么它必须有一个地址。在第 09 行，该`main`函数调用内置函数`println`来显示`count`变量的“值”和“地址” 。

**清单 2**

```
09    println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")
```

使用与号`&`运算符来获取变量位置的地址并不新鲜，其他语言也使用此运算符。如果您在 32 位架构（如操场）上运行代码，则第 09 行的输出应类似于以下输出：

**清单 3**

```
count:  Value Of[ 10 ]  Addr Of[ 0x10429fa4 ]
```

### 函数调用

接下来在第 12 行，该`main`函数调用该`increment`函数。

**清单 4**

```
12    increment(count)
```

进行函数调用意味着 goroutine 需要在堆栈上构建一个新的内存部分。然而，事情有点复杂。为成功调用此函数，数据应跨帧边界传递并在转换期间放入新帧。具体来说，期望在调用期间复制和传递整数值。您可以通过查看`increment`第 18 行的函数声明来了解此要求。

**清单 5**

```
18 func increment(inc int) {
```

如果您`increment`再次查看第 12 行的函数调用，您可以看到代码正在传递`count`变量的“值” 。该值将被复制、传递并放置到`increment`函数的新框架中。请记住，该`increment`函数只能直接在其自己的框架内读取和写入内存，因此它需要该`inc`变量来接收、存储和访问它自己的`count`传递值的副本。

就在`increment`函数内部的代码开始执行之前，goroutine 的堆栈（在非常高的级别）将如下所示：

**图2**

![img](https://www.ardanlabs.com/images/goinggo/80_figure2.png)

您可以看到堆栈现在有两个框架，一个用于`main`其下方，一个用于`increment`. 在 for 的框架内`increment`，您会看到`inc`变量，它包含`10`在函数调用期间复制和传递的值。`inc`变量的地址`0x10429f98`在内存中较低，因为帧从堆栈中取出，这只是一个实现细节，没有任何意义。重要的是 goroutine`count`从框架中获取的值，并将该值的`main`副本放置在框架中以`increment`使用该`inc`变量。

内部的其余代码`increment`递增并显示`inc`变量的“值”和“地址” 。

**清单 6**

```
21    inc++
22    println("inc:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
```

第 22 行的输出应该是这样的：

**清单 7**

```
inc:    Value Of[ 11 ]  Addr Of[ 0x10429f98 ]
```

这是执行这些相同代码行后堆栈的样子：

**图 3**

![img](https://www.ardanlabs.com/images/goinggo/80_figure3.png)

在第 21 行和第 22 行执行后，`increment`函数返回并且控制权返回给`main`函数。然后`main`函数`count`在第 14 行再次显示局部变量的“值”和“地址” 。

**清单 8**

```
14    println("count:\tValue Of[",count, "]\tAddr Of[", &count, "]")
```

程序的完整输出应该是这样的：

**清单 9**

```
count:  Value Of[ 10 ]  Addr Of[ 0x10429fa4 ]
inc:    Value Of[ 11 ]  Addr Of[ 0x10429f98 ]
count:  Value Of[ 10 ]  Addr Of[ 0x10429fa4 ]
```

在调用 之前和之后，`count`框架中的 值`main`是相同的`increment`。

### 函数返回

当函数返回并且控制权返回到调用函数时，堆栈上的内存实际发生了什么？简短的回答是什么。这是`increment`函数返回后堆栈的样子：

**图 4**

![img](https://www.ardanlabs.com/images/goinggo/80_figure4.png)

堆栈看起来与图 3 完全相同，只是与`increment`函数关联的帧现在被认为是无效内存。这是因为框架`main`现在是活动框架。为该`increment`功能构建的内存保持不变。

清理返回函数帧的内存是浪费时间，因为您不知道是否会再次需要该内存。所以记忆就保持原样。在每次函数调用期间，当帧被获取时，该帧的堆栈内存被清除干净。这是通过初始化放置在框架中的任何值来完成的。因为所有值都至少被初始化为它们的“零值”，所以堆栈在每次函数调用时都会正确地清理自己。

### 共享值(指针)

如果`increment`函数直接对`count`存在于框架内的变量进行操作很重要，该`main`怎么办？这就是指针的用武之地。指针有一个目的，即与函数共享一个值，以便函数可以读取和写入该值，即使该值不直接存在于其自身的框架内。

如果“分享”这个词不是从你嘴里说出来的，你就不需要使用指针。在学习指针时，重要的是要考虑使用清晰的词汇而不是运算符或语法。所以请记住，指针用于共享，并在`&`您阅读代码时替换“共享”一词的运算符。

### 指针类型

对于由您或语言本身声明的每种类型，您都可以免费获得可用于共享的补码指针类型。已经存在一个名为的内置类型，`int`因此有一个名为的补码指针类型`*int`。如果您声明一个名为 的类型`User`，您将免费获得一个名为 的指针类型`*User`。

所有指针类型都具有相同的两个特征。首先，它们从字符 开始`*`。其次，它们都具有相同的内存大小和表示形式，即表示地址的 4 或 8 个字节。在 32 位架构上，指针需要 4 字节的内存，而在 64 位架构上，它们需要 8 字节的内存。

*在规范中，[指针类型](https://golang.org/ref/spec#PointerType)被认为是[类型文字](https://golang.org/ref/spec#Types)，这意味着它们是由现有类型组成的未命名类型。*

### 间接内存访问

看看这个执行“按值”传递地址的函数调用的小程序。这将与函数共享堆栈帧中的`count`变量：`main``increment`

**清单 10**

```
01 package main
02
03 func main() {
04
05    // Declare variable of type int with a value of 10.
06    count := 10
07
08    // Display the "value of" and "address of" count.
09    println("count:\tValue Of[", count, "]\t\tAddr Of[", &count, "]")
10
11    // Pass the "address of" count.
12    increment(&count)
13
14    println("count:\tValue Of[", count, "]\t\tAddr Of[", &count, "]")
15 }
16
17 //go:noinline
18 func increment(inc *int) {
19
20    // Increment the "value of" count that the "pointer points to". (dereferencing)
21    *inc++
22    println("inc:\tValue Of[", inc, "]\tAddr Of[", &inc, "]\tValue Points To[", *inc, "]")
23 }
```

与原始程序相比，此程序进行了三个有趣的更改。这是第 12 行的第一个更改：

**清单 11**

```
12    increment(&count)
```

这次在第 12 行，代码不是复制和传递“value of”`count`而是“address of” `count`。您现在可以说，我正在`count`与`increment`函数“共享”变量。。

理解这仍然是一个“值传递”，唯一的区别是你传递的值是一个地址而不是一个整数。地址也是值；这是为函数调用复制和跨帧边界传递的内容。

由于地址的值正在被复制和传递，因此您需要在 的帧内有一个变量`increment`来接收和存储这个基于整数的地址。这是整数指针变量的声明在第 18 行出现的地方。

**清单 12**

```
18 func increment(inc *int) {
```

如果要传递`User`值的地址，则需要将该变量声明为`*User`. 尽管所有指针变量都存储地址值，但它们不能传递任何地址，只能传递与指针类型关联的地址。这是关键，共享值的原因是因为接收函数需要对该值执行读取或写入操作。您需要任何值的类型信息才能对其进行读写。编译器将确保只有与正确指针类型关联的值才能与该函数共享。

这是函数调用后堆栈的样子`increment`：

**图 5**

![img](https://www.ardanlabs.com/images/goinggo/80_figure5.png)

您可以在图 5 中看到当使用地址作为值执行“传递值”时堆栈的样子。`increment`函数框架内的指针变量现在指向`count`位于 框架内的变量`main`。

现在使用指针变量，该函数可以对`count`位于框架内的变量执行间接读修改写操作`main`。

**清单 13**

```
21    *inc++
```

这次该`*`字符充当运算符并应用于指针变量。使用`*`作为运算符的意思是“指针指向的值”。指针变量允许在使用它的函数框架之外进行间接内存访问。有时，这种间接读取或写入称为取消引用指针。该`increment`函数仍然必须在其框架内有一个指针变量，它可以直接读取以执行间接访问。

现在在图 6 中，您可以看到执行第 21 行后堆栈的样子。

**图 6**

![img](https://www.ardanlabs.com/images/goinggo/80_figure6.png)

这是该程序的最终输出：

**清单 14**

```
count:  Value Of[ 10 ]   	   	Addr Of[ 0x10429fa4 ]
inc:    Value Of[ 0x10429fa4 ]  	Addr Of[ 0x10429f98 ]   Value Points To[ 11 ]
count:  Value Of[ 11 ]   	   	Addr Of[ 0x10429fa4 ]
```

您可以看到`inc`指针变量的“值”与变量的“地址”相同`count`。这建立了共享关系，允许间接访问框架外的内存。一旦`increment`函数通过指针执行写操作，`main`当控制返回时，函数会看到变化。

### 指针变量并不特殊

指针变量并不特殊，因为它们与任何其他变量一样都是变量。他们有一个内存分配，他们持有一个值。碰巧的是，所有指针变量，无论它们可以指向什么类型的值，总是具有相同的大小和表示形式。令人困惑的是该`*`字符在代码中充当运算符并用于声明指针类型。如果您可以将类型声明与指针操作区分开来，这有助于减轻一些混淆。

### 结论

这篇文章描述了指针背后的目的以及堆栈和指针机制在 Go 中是如何工作的。这是理解编写一致和可读代码所需的机制、设计理念和指南的第一步。

总之，这就是你学到的：

- 函数在帧边界范围内执行，帧边界为每个函数提供单独的存储空间。
- 调用函数时，两个帧之间会发生转换。
- “按值”传递数据的好处是可读性。
- 堆栈很重要，因为它为分配给每个单独函数的帧边界提供了物理内存空间。
- 活动帧以下的所有堆栈内存都无效，但活动帧及以上的内存有效。
- 进行函数调用意味着 goroutine 需要在堆栈上构建一个新的内存部分。
- 在每次函数调用期间，当帧被获取时，该帧的堆栈内存被清除干净。
- 指针有一个目的，即与函数共享一个值，以便函数可以读取和写入该值，即使该值不直接存在于其自身的框架内。
- 对于由您或语言本身声明的每种类型，您都可以免费获得一个可用于共享的指针类型。
- 指针变量允许在使用它的函数框架之外进行间接内存访问。
- 指针变量并不特殊，因为它们与任何其他变量一样都是变量。他们有一个内存分配，他们持有一个值。
