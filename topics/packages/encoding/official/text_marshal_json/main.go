package main

import (
	"encoding/json"
	"fmt"
	"log"
	"strings"
)

/**
// TextUnmarshaler is the interface implemented by an object that can
// unmarshal a textual representation of itself.
// TextUnmarshaler 是一个对象实现的接口，它可以解组自身的文本表示。
//
// UnmarshalText must be able to decode the form generated by MarshalText.
// UnmarshalText 必须能够解码 MarshalText 生成的表单。
// UnmarshalText must copy the text if it wishes to retain the text
// after returning.
// 如果 UnmarshalText 希望在返回后保留文本，则必须复制该文本。

// TextMarshaler is the interface implemented by an object that can
// marshal itself into a textual form.
// TextMarshaler 是一个对象实现的接口，它可以将自己编组为文本形式。
//
// MarshalText encodes the receiver into UTF-8-encoded text and returns the result.
// MarshalText 将接收者编码为 UTF-8 编码的文本并返回结果。
*/

type Size int

const (
	Unrecognized Size = iota
	small
	large
)

// UnmarshalText 自定义文本反转义
func (s *Size) UnmarshalText(text []byte) error {
	name := string(text)
	switch strings.ToLower(name) {
	default:
		*s = Unrecognized
	case "small":
		*s = small
	case "large":
		*s = large
	}
	return nil
}

// MarshalText 转义成文本
func (s *Size) MarshalText() ([]byte, error) {
	var name string
	switch *s {
	default:
		name = "unrecognized"
	case small:
		name = "small"
	case large:
		name = "large"
	}

	return []byte(name), nil
}

func main() {
	blob := `["small","regular","large","unrecognized","small","normal","small","large"]`
	var inventory []Size
	if err := json.Unmarshal([]byte(blob), &inventory); err != nil {
		log.Println(err)
		return
	}
	counts := make(map[Size]int)
	for _, i := range inventory {
		counts[i] += 1
	}
	fmt.Printf(`Inventory Counts
Small: %d
Large: %d
Unrecognized: %d
`, counts[small], counts[large], counts[Unrecognized])
}
